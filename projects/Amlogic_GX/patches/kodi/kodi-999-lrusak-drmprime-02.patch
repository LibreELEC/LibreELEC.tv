From 3b04ac4b85450cc045db38ec561bbf3eb5f7c455 Mon Sep 17 00:00:00 2001
From: Lukas Rusak <lorusak@gmail.com>
Date: Tue, 13 Feb 2018 16:07:26 -0800
Subject: [PATCH] utils/EGLUtils: add class CEGLImage

---
 xbmc/utils/EGLUtils.cpp | 100 ++++++++++++++++++++++++++++++++++++++++++++++++
 xbmc/utils/EGLUtils.h   |  44 +++++++++++++++++++++
 2 files changed, 144 insertions(+)

diff --git a/xbmc/utils/EGLUtils.cpp b/xbmc/utils/EGLUtils.cpp
index 723f7e923233..14ed44c496a1 100644
--- a/xbmc/utils/EGLUtils.cpp
+++ b/xbmc/utils/EGLUtils.cpp
@@ -272,3 +272,103 @@ void CEGLContextUtils::SwapBuffers()
 
   eglSwapBuffers(m_eglDisplay, m_eglSurface);
 }
+
+/* --- CEGLImage -------------------------------------------*/
+
+#ifndef DRM_FORMAT_MOD_INVALID
+const uint64_t DRM_FORMAT_MOD_INVALID = 72057594037927935;
+#endif
+
+namespace
+{
+  const EGLint eglDmabufPlaneFdAttr[CEGLImage::MAX_NUM_PLANES] =
+  {
+    EGL_DMA_BUF_PLANE0_FD_EXT,
+    EGL_DMA_BUF_PLANE1_FD_EXT,
+    EGL_DMA_BUF_PLANE2_FD_EXT,
+  };
+
+  const EGLint eglDmabufPlaneOffsetAttr[CEGLImage::MAX_NUM_PLANES] =
+  {
+    EGL_DMA_BUF_PLANE0_OFFSET_EXT,
+    EGL_DMA_BUF_PLANE1_OFFSET_EXT,
+    EGL_DMA_BUF_PLANE2_OFFSET_EXT,
+  };
+
+  const EGLint eglDmabufPlanePitchAttr[CEGLImage::MAX_NUM_PLANES] =
+  {
+    EGL_DMA_BUF_PLANE0_PITCH_EXT,
+    EGL_DMA_BUF_PLANE1_PITCH_EXT,
+    EGL_DMA_BUF_PLANE2_PITCH_EXT,
+  };
+
+  const EGLint eglDmabufPlaneModifierLoAttr[CEGLImage::MAX_NUM_PLANES] =
+  {
+    EGL_DMA_BUF_PLANE0_MODIFIER_LO_EXT,
+    EGL_DMA_BUF_PLANE1_MODIFIER_LO_EXT,
+    EGL_DMA_BUF_PLANE2_MODIFIER_LO_EXT,
+  };
+
+  const EGLint eglDmabufPlaneModifierHiAttr[CEGLImage::MAX_NUM_PLANES] =
+  {
+    EGL_DMA_BUF_PLANE0_MODIFIER_HI_EXT,
+    EGL_DMA_BUF_PLANE1_MODIFIER_HI_EXT,
+    EGL_DMA_BUF_PLANE2_MODIFIER_HI_EXT,
+  };
+} // namespace
+
+CEGLImage::CEGLImage(EGLDisplay display) :
+  m_display(display)
+{
+  m_eglCreateImageKHR = CEGLUtils::GetRequiredProcAddress<PFNEGLCREATEIMAGEKHRPROC>("eglCreateImageKHR");
+  m_eglDestroyImageKHR = CEGLUtils::GetRequiredProcAddress<PFNEGLDESTROYIMAGEKHRPROC>("eglDestroyImageKHR");
+  m_glEGLImageTargetTexture2DOES = CEGLUtils::GetRequiredProcAddress<PFNGLEGLIMAGETARGETTEXTURE2DOESPROC>("glEGLImageTargetTexture2DOES");
+}
+
+bool CEGLImage::CreateImage(EglAttrs imageAttrs)
+{
+  CEGLAttributes<22> attribs;
+  attribs.Add({{EGL_WIDTH, imageAttrs.width},
+               {EGL_HEIGHT, imageAttrs.height},
+               {EGL_LINUX_DRM_FOURCC_EXT, static_cast<EGLint>(imageAttrs.format)}});
+
+  /* this should be included later as some platforms need it */
+  attribs.Add({{EGL_YUV_COLOR_SPACE_HINT_EXT, EGL_ITU_REC601_EXT},
+               {EGL_SAMPLE_RANGE_HINT_EXT, EGL_YUV_FULL_RANGE_EXT},
+               {EGL_YUV_CHROMA_VERTICAL_SITING_HINT_EXT, EGL_YUV_CHROMA_SITING_0_EXT},
+               {EGL_YUV_CHROMA_HORIZONTAL_SITING_HINT_EXT, EGL_YUV_CHROMA_SITING_0_EXT}});
+
+  for (int i = 0; i < MAX_NUM_PLANES; i++)
+  {
+    if (imageAttrs.planes[i].fd != 0)
+    {
+      attribs.Add({{eglDmabufPlaneFdAttr[i], imageAttrs.planes[i].fd},
+                   {eglDmabufPlaneOffsetAttr[i], imageAttrs.planes[i].offset},
+                   {eglDmabufPlanePitchAttr[i], imageAttrs.planes[i].pitch}});
+
+      if (imageAttrs.planes[i].modifier != DRM_FORMAT_MOD_INVALID)
+        attribs.Add({{eglDmabufPlaneModifierLoAttr[i], static_cast<EGLint>(imageAttrs.planes[i].modifier & 0xFFFFFFFF)},
+                     {eglDmabufPlaneModifierHiAttr[i], static_cast<EGLint>(imageAttrs.planes[i].modifier >> 32)}});
+    }
+  }
+
+  m_image = m_eglCreateImageKHR(m_display, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, nullptr, attribs.Get());
+
+  if(!m_image)
+  {
+    CLog::Log(LOGERROR, "CEGLImage::%s - failed to import buffer into EGL image: %d", __FUNCTION__, eglGetError());
+    return false;
+  }
+
+  return true;
+}
+
+void CEGLImage::UploadImage(GLenum textureTarget)
+{
+  m_glEGLImageTargetTexture2DOES(textureTarget, m_image);
+}
+
+void CEGLImage::DestroyImage()
+{
+  m_eglDestroyImageKHR(m_display, m_image);
+}
diff --git a/xbmc/utils/EGLUtils.h b/xbmc/utils/EGLUtils.h
index d91527ed06fd..73caf93ad6b5 100644
--- a/xbmc/utils/EGLUtils.h
+++ b/xbmc/utils/EGLUtils.h
@@ -24,6 +24,9 @@
 #include <stdexcept>
 
 #include <EGL/egl.h>
+#include <EGL/eglext.h>
+
+#include "system_gl.h"
 
 #include "StringUtils.h"
 
@@ -144,3 +147,44 @@ class CEGLContextUtils
   EGLContext m_eglContext;
   EGLConfig m_eglConfig;
 };
+
+/* --- CEGLImage ---------------------------------------------*/
+
+class CEGLImage
+{
+public:
+  static const int MAX_NUM_PLANES{3};
+
+  struct EglPlane
+  {
+    int fd{0};
+    int offset{0};
+    int pitch{0};
+    uint64_t modifier{0};
+  };
+
+  struct EglAttrs
+  {
+    int width{0};
+    int height{0};
+    uint32_t format{0};
+    std::array<EglPlane, MAX_NUM_PLANES> planes;
+  };
+
+  explicit CEGLImage(EGLDisplay display);
+
+  CEGLImage(CEGLImage const& other) = delete;
+  CEGLImage& operator=(CEGLImage const& other) = delete;
+
+  bool CreateImage(EglAttrs imageAttrs);
+  void UploadImage(GLenum textureTarget);
+  void DestroyImage();
+
+private:
+  EGLDisplay m_display{nullptr};
+  EGLImage m_image{nullptr};
+
+  PFNEGLCREATEIMAGEKHRPROC m_eglCreateImageKHR{nullptr};
+  PFNEGLDESTROYIMAGEKHRPROC m_eglDestroyImageKHR{nullptr};
+  PFNGLEGLIMAGETARGETTEXTURE2DOESPROC m_glEGLImageTargetTexture2DOES{nullptr};
+};
